{"mappings":"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","sources":["src/index.ts","src/auth.ts","src/utils.ts","src/ble.ts","src/device.ts","src/queue.ts","src/fs.ts","src/http.ts","src/managed.ts","src/session.ts","src/metrics.ts","src/params.ts","src/relay.ts","src/serial.ts","src/update.ts"],"sourcesContent":["export * from \"./auth\";\nexport * from \"./ble\";\nexport * from \"./device\";\nexport * from \"./fs\";\nexport * from \"./http\";\nexport * from \"./managed\";\nexport * from \"./metrics\";\nexport * from \"./params\";\nexport * from \"./queue\";\nexport * from \"./relay\";\nexport * from \"./serial\";\nexport * from \"./session\";\nexport * from \"./update\";\nexport * from \"./utils\";\n","import { Session } from \"./session\";\nimport { compare, hmac256, pack } from \"./utils\";\n\nconst authEndpoint = 0x6;\n\nexport interface AuthData {\n  uuid: Uint8Array;\n  product: number;\n  revision: number;\n  batch: number;\n  date: number;\n}\n\nexport async function authStatus(\n  s: Session,\n  timeout: number = 5000\n): Promise<boolean> {\n  // send command\n  await s.send(authEndpoint, pack(\"o\", 0), 0);\n\n  // await reply\n  const [reply] = await s.receive(authEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length !== 1) {\n    throw new Error(\"invalid reply\");\n  }\n\n  return reply[0] === 1;\n}\n\nexport async function authProvision(\n  s: Session,\n  key: Uint8Array,\n  data: AuthData,\n  timeout: number = 5000\n): Promise<void> {\n  // validate key\n  if (key.length !== 32) {\n    throw new Error(\"key must be exactly 32 bytes\");\n  }\n\n  // send command\n  const cmd = pack(\n    \"obobhhhib\",\n    1, // command\n    key,\n    1, // version\n    data.uuid,\n    data.product,\n    data.revision,\n    data.batch,\n    data.date,\n    new Uint8Array(5).fill(0)\n  );\n  await s.send(authEndpoint, cmd, timeout);\n}\n\nexport async function authDescribe(\n  s: Session,\n  key: Uint8Array = undefined,\n  timeout: number = 5000\n): Promise<AuthData> {\n  // send command\n  await s.send(authEndpoint, pack(\"o\", 2), 0);\n\n  // receive reply\n  const [reply] = await s.receive(authEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length < 32) {\n    throw new Error(\"invalid reply\");\n  }\n\n  // check version\n  if (reply[0] !== 1) {\n    throw new Error(`invalid version: ${reply[0]}`);\n  }\n\n  // parse reply\n  const uuid = reply.slice(1, 17);\n  const product = reply[17] | (reply[18] << 8);\n  const revision = reply[19] | (reply[20] << 8);\n  const batch = reply[21] | (reply[22] << 8);\n  const date =\n    reply[23] | (reply[24] << 8) | (reply[25] << 16) | (reply[26] << 24);\n  const signature = reply.slice(27, 32);\n\n  // verify signature\n  const expectedSignature = await hmac256(key, reply.slice(0, 27));\n  if (compare(expectedSignature, signature)) {\n    throw new Error(\"invalid signature\");\n  }\n\n  return {\n    uuid,\n    product,\n    revision,\n    batch,\n    date,\n  };\n}\n\nexport async function authAttest(\n  s: Session,\n  challenge: Uint8Array,\n  timeout: number = 5000\n): Promise<Uint8Array> {\n  // send command\n  await s.send(authEndpoint, pack(\"ob\", 3, challenge), 0);\n\n  // await reply\n  const [reply] = await s.receive(authEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length !== 32) {\n    throw new Error(\"invalid reply\");\n  }\n\n  return reply;\n}\n","const utf8Enc = new TextEncoder();\nconst utf8Dec = new TextDecoder();\n\nexport function toBuffer(string: string): Uint8Array {\n  return utf8Enc.encode(string);\n}\n\nexport function toString(buffer: ArrayBufferLike): string {\n  return utf8Dec.decode(buffer);\n}\n\nexport function toBase64(buffer: ArrayBufferLike): Uint8Array {\n  return toBuffer(btoa(String.fromCharCode(...new Uint8Array(buffer))));\n}\n\nexport function fromBase64(base64: string): Uint8Array {\n  return new Uint8Array(\n    atob(base64)\n      .split(\"\")\n      .map((c) => c.charCodeAt(0))\n  );\n}\n\nexport function concat(buf1: Uint8Array, buf2: Uint8Array): Uint8Array {\n  const buf = new Uint8Array(buf1.byteLength + buf2.byteLength);\n  buf.set(buf1, 0);\n  buf.set(buf2, buf1.byteLength);\n  return buf;\n}\n\nexport function random(length: number): string {\n  const characters =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let result = \"\";\n  for (let i = 0; i < length; i++) {\n    const randomIndex = Math.floor(Math.random() * characters.length);\n    result += characters.charAt(randomIndex);\n  }\n  return result;\n}\n\nexport function securerRandom(length: number): Uint8Array {\n  return window.crypto.getRandomValues(new Uint8Array(length));\n}\n\nexport async function hmac256(\n  key: Uint8Array,\n  challenge: Uint8Array\n): Promise<Uint8Array> {\n  // import HMAC key\n  const cryptoKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    key,\n    { name: \"HMAC\", hash: { name: \"SHA-256\" } },\n    false,\n    [\"sign\"]\n  );\n\n  // generate the HMAC\n  const res = await window.crypto.subtle.sign(\"HMAC\", cryptoKey, challenge);\n\n  return new Uint8Array(res);\n}\n\nexport function requestFile(file: File): Promise<ArrayBuffer> {\n  return new Promise((resolve, reject) => {\n    const r = new FileReader();\n    r.onload = () => {\n      resolve(r.result as ArrayBuffer);\n    };\n    r.onerror = (event) => {\n      reject(event);\n    };\n    r.readAsArrayBuffer(file);\n  });\n}\n\nexport function pack(fmt: string, ...args: any[]): Uint8Array {\n  // calculate size\n  let size = 0;\n  for (const [index, arg] of args.entries()) {\n    switch (fmt.charAt(index)) {\n      case \"s\":\n      case \"b\":\n        size += arg.length;\n        break;\n      case \"o\":\n        size += 1;\n        break;\n      case \"h\":\n        size += 2;\n        break;\n      case \"i\":\n        size += 4;\n        break;\n      case \"q\":\n        size += 8;\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n  }\n\n  // create buffer and view\n  const buffer = new Uint8Array(size);\n  const view = new DataView(buffer.buffer);\n\n  // write arguments\n  let offset = 0;\n  for (const [index, arg] of args.entries()) {\n    switch (fmt.charAt(index)) {\n      case \"s\":\n        buffer.set(toBuffer(arg), offset);\n        offset += arg.length;\n        break;\n      case \"b\":\n        buffer.set(arg, offset);\n        offset += arg.length;\n        break;\n      case \"o\":\n        view.setUint8(offset, arg);\n        offset += 1;\n        break;\n      case \"h\":\n        view.setUint16(offset, arg, true);\n        offset += 2;\n        break;\n      case \"i\":\n        view.setUint32(offset, arg, true);\n        offset += 4;\n        break;\n      case \"q\":\n        view.setBigUint64(offset, arg, true);\n        offset += 8;\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n  }\n\n  return buffer;\n}\n\nexport function unpack(fmt: string, buffer: Uint8Array): any[] {\n  // get view\n  const view = new DataView(buffer.buffer);\n\n  // prepare result\n  const result: any[] = [];\n\n  // read arguments\n  let pos = 0;\n  for (const code of fmt) {\n    switch (code) {\n      case \"s\": {\n        let end = buffer.indexOf(0, pos);\n        if (end === -1) end = buffer.length;\n        result.push(toString(buffer.slice(pos, end)));\n        pos = end;\n        break;\n      }\n      case \"b\": {\n        result.push(buffer.slice(pos));\n        pos = buffer.length;\n        break;\n      }\n      case \"o\": {\n        result.push(buffer[pos]);\n        pos += 1;\n        break;\n      }\n      case \"h\": {\n        result.push(view.getUint16(pos, true));\n        pos += 2;\n        break;\n      }\n      case \"i\": {\n        result.push(view.getUint32(pos, true));\n        pos += 4;\n        break;\n      }\n      case \"q\": {\n        result.push(view.getBigUint64(pos, true));\n        pos += 8;\n        break;\n      }\n      default:\n        throw new Error(`Invalid format code: ${code}`);\n    }\n  }\n\n  return result;\n}\n\nexport function compare(buf1: Uint8Array, buf2: Uint8Array): boolean {\n  // check lengths\n  if (buf1.byteLength !== buf2.byteLength) {\n    return false;\n  }\n\n  // compare bytes\n  const view1 = new DataView(buf1.buffer);\n  const view2 = new DataView(buf2.buffer);\n  let i = buf1.byteLength;\n  while (i--) {\n    if (view1.getUint8(i) !== view2.getUint8(i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { Device, Channel, Queue, QueueList } from \"./device\";\n\nconst svcUUID = \"632fba1b-4861-4e4f-8103-ffee9d5033b5\";\nconst charUUID = \"0360744b-a61b-00ad-c945-37f3634130f3\";\n\nexport async function bleRequest(): Promise<Device | null> {\n  // request device\n  let dev: BluetoothDevice | null;\n  try {\n    dev = await navigator.bluetooth.requestDevice({\n      filters: [{ services: [svcUUID] }],\n    });\n  } catch (err) {\n    // ignore\n  }\n  if (!dev) {\n    return null;\n  }\n\n  return new BLEDevice(dev);\n}\n\nexport class BLEDevice implements Device {\n  private dev: BluetoothDevice;\n  private svc: BluetoothRemoteGATTService | null = null;\n  private char: BluetoothRemoteGATTCharacteristic | null = null;\n  private ch: Channel | null = null;\n\n  constructor(dev: BluetoothDevice) {\n    // store device\n    this.dev = dev;\n\n    // close open chanel if disconnected\n    this.dev.addEventListener(\"gattserverdisconnected\", () => {\n      if (this.ch) {\n        this.ch.close();\n        this.ch = null;\n      }\n    });\n  }\n\n  id() {\n    return \"ble/\" + this.dev.id;\n  }\n\n  async open(): Promise<Channel> {\n    // check channel\n    if (this.ch) {\n      throw new Error(\"channel already open\");\n    }\n\n    // connect, if not connected already\n    if (!this.dev.gatt.connected) {\n      await this.dev.gatt.connect();\n    }\n\n    // get service and characteristic if not available\n    if (!this.svc) {\n      this.svc = await this.dev.gatt.getPrimaryService(svcUUID);\n      this.char = await this.svc.getCharacteristic(charUUID);\n      if (!this.char) {\n        throw new Error(\"missing characteristic\");\n      }\n    }\n\n    // create list\n    const subscribers = new QueueList();\n\n    // prepare handler\n    const handler = () => {\n      const data = new Uint8Array(this.char.value.buffer);\n      subscribers.dispatch(data);\n    };\n\n    // subscribe to messages\n    this.char.addEventListener(\"characteristicvaluechanged\", handler);\n    await this.char.startNotifications();\n\n    // prepare flag\n    let closed = false;\n\n    // create channel\n    this.ch = {\n      name: () => \"ble\",\n      valid: () => {\n        return this.dev.gatt.connected && !closed;\n      },\n      subscribe: (q: Queue) => {\n        subscribers.add(q);\n      },\n      unsubscribe(queue: Queue) {\n        subscribers.drop(queue);\n      },\n      write: async (data: Uint8Array) => {\n        await this.char.writeValueWithoutResponse(data);\n      },\n      close: () => {\n        this.char.removeEventListener(\"characteristicvaluechanged\", handler);\n        this.ch = null;\n        closed = true;\n      },\n    };\n\n    return this.ch;\n  }\n}\n","import { AsyncQueue } from \"./queue\";\n\n/**\n * Device represents a device that can be communicated with.\n */\nexport interface Device {\n  /**\n   * Returns a stable identifier for the device.\n   */\n  id(): string;\n\n  /**\n   * Open opens a channel to the device. An opened channel must fail or be\n   * closed before another channel can be opened.\n   */\n  open(): Promise<Channel>;\n}\n\n/**\n * Queue is used to receive messages from a channel.\n */\nexport class Queue extends AsyncQueue<Uint8Array> {}\n\n/**\n * QueueList is used to manage a list of queues.\n */\nexport class QueueList {\n  private queues: Queue[] = [];\n\n  /**\n   * Adds a queue to the list.\n   */\n  add(queue: Queue) {\n    if (!this.queues.includes(queue)) {\n      this.queues.push(queue);\n    }\n  }\n\n  /**\n   * Removes a queue from the list.\n   */\n  drop(queue: Queue) {\n    const index = this.queues.indexOf(queue);\n    if (index >= 0) {\n      this.queues.splice(index, 1);\n    }\n  }\n\n  /**\n   * Dispatches data to all queues.\n   */\n  dispatch(data: Uint8Array) {\n    for (let queue of this.queues) {\n      queue.push(data);\n    }\n  }\n}\n\n/**\n * Channel provides the mechanism to exchange messages between a device and a client.\n */\nexport interface Channel {\n  name(): string;\n  valid(): boolean;\n  subscribe(queue: Queue): void;\n  unsubscribe(queue: Queue): void;\n  write(data: Uint8Array): Promise<void>;\n  close(): void;\n}\n\n/**\n * Message represents a message exchanged between a device and client.\n */\nexport class Message {\n  session: number; // uint16\n  endpoint: number; // uint8\n  data: Uint8Array | null;\n\n  constructor(session: number, endpoint: number, data: Uint8Array | null) {\n    this.session = session;\n    this.endpoint = endpoint;\n    this.data = data;\n  }\n\n  /**\n   * Returns the size of the message.\n   */\n  size(): number {\n    return this.data?.length ?? 0;\n  }\n}\n\n/**\n * Read reads a message from the queue.\n */\nexport async function read(queue: Queue, timeout: number): Promise<Message> {\n  // read from queue\n  const data = await queue.pop(timeout);\n  if (!data) {\n    throw new Error(\"timeout\");\n  }\n\n  // check length and version\n  if (data.length < 4 || data[0] !== 1) {\n    throw new Error(\"invalid message\");\n  }\n\n  // get view\n  const view = new DataView(data.buffer);\n\n  return new Message(\n    view.getUint16(1, true),\n    data[3],\n    data.length > 4 ? data.slice(4) : null\n  );\n}\n\n/**\n * Write writes a message to the channel.\n */\nexport async function write(ch: Channel, msg: Message): Promise<void> {\n  // prepare data\n  const data = new Uint8Array(4 + msg.size());\n  const view = new DataView(data.buffer);\n  view.setUint8(0, 1); // version\n  view.setUint16(1, msg.session, true);\n  view.setUint8(3, msg.endpoint);\n  if (msg.data) {\n    data.set(msg.data, 4);\n  }\n\n  // write data\n  await ch.write(data);\n}\n","export class AsyncQueue<Type> {\n  private queue: Type[] = [];\n  private waiters: ((item: Type | null) => void)[] = [];\n\n  push(item: Type) {\n    // add to back\n    this.queue.push(item);\n\n    // process queue\n    while (this.waiters.length > 0 && this.queue.length > 0) {\n      const resolve = this.waiters.shift();\n      resolve(this.queue.shift());\n    }\n  }\n\n  pop(timeout: number): Promise<Type | null> {\n    // check if there is an item in the queue\n    if (this.queue.length > 0) {\n      return Promise.resolve(this.queue.shift());\n    }\n\n    return new Promise((resolve: (value: Type | null) => void): void => {\n      // add waiter\n      this.waiters.push(resolve);\n\n      // handle timeout\n      if (timeout > 0) {\n        setTimeout((): void => {\n          if (this.waiters.includes(resolve)) {\n            const index: number = this.waiters.indexOf(resolve);\n            this.waiters.splice(index, 1);\n            resolve(null);\n          }\n        }, timeout);\n      }\n    });\n  }\n}\n","import { Session } from \"./session\";\nimport { pack, unpack } from \"./utils\";\n\nconst fsEndpoint = 0x3;\n\nexport interface FSInfo {\n  name: string;\n  isDir: boolean;\n  size: number;\n}\n\nexport async function statPath(\n  session: Session,\n  path: string\n): Promise<FSInfo | null> {\n  // send command\n  const cmd = pack(\"os\", 0, path);\n  await send(session, cmd, false);\n\n  // await reply\n  const reply = await receive(session, false);\n\n  // verify \"info\" reply\n  if (reply.length !== 6 || reply[0] !== 1) {\n    throw new Error(\"invalid message\");\n  }\n\n  // unpack \"info\" reply\n  const args = unpack(\"oi\", reply.slice(1));\n\n  return {\n    name: \"\",\n    isDir: args[0] === 1,\n    size: args[1],\n  };\n}\n\nexport async function listDir(\n  session: Session,\n  dir: string\n): Promise<FSInfo[]> {\n  // send command\n  const cmd = pack(\"os\", 1, dir);\n  await send(session, cmd, false);\n\n  // prepare infos\n  const infos = [];\n\n  while (true) {\n    // await reply\n    const reply = await receive(session, true);\n    if (!reply) {\n      return infos;\n    }\n\n    // verify \"info\" reply\n    if (reply.byteLength < 7 || reply[0] !== 1) {\n      throw new Error(\"invalid message\");\n    }\n\n    // unpack \"info\" reply\n    const args = unpack(\"ois\", reply.slice(1));\n\n    // add info\n    infos.push({\n      name: args[2],\n      isDir: args[0] == 1,\n      size: args[1],\n    });\n  }\n}\n\nexport async function readFile(\n  session: Session,\n  file: string,\n  report: (count: number) => void = null\n): Promise<Uint8Array> {\n  // stat file\n  const info = await statPath(session, file);\n\n  // prepare data\n  const data = new Uint8Array(info.size);\n\n  // read file in chunks of 5 KB\n  let offset = 0;\n  while (offset < info.size) {\n    // determine length\n    const length = Math.min(5000, info.size - offset);\n\n    // read range\n    let range = await readFileRange(\n      session,\n      file,\n      offset,\n      length,\n      (pos: number) => {\n        if (report) {\n          report(offset + pos);\n        }\n      }\n    );\n\n    // append range\n    data.set(range, offset);\n    offset += range.byteLength;\n  }\n\n  return data;\n}\n\nexport async function readFileRange(\n  session: Session,\n  file: string,\n  offset: number,\n  length: number,\n  report: (count: number) => void = null\n): Promise<Uint8Array> {\n  // send \"open\" command\n  let cmd = pack(\"oos\", 2, 0, file);\n  await send(session, cmd, true);\n\n  // send \"read\" command\n  cmd = pack(\"oii\", 3, offset, length);\n  await send(session, cmd, false);\n\n  // prepare data\n  let data = new Uint8Array(length);\n\n  // prepare counter\n  let count = 0;\n\n  while (true) {\n    // await reply\n    let reply = await receive(session, true);\n    if (!reply) {\n      break;\n    }\n\n    // verify \"chunk\" reply\n    if (reply.byteLength <= 5 || reply[0] !== 2) {\n      throw new Error(\"invalid message\");\n    }\n\n    // get offset\n    let replyOffset = unpack(\"i\", reply.slice(1))[0];\n\n    // verify offset\n    if (replyOffset !== offset + count) {\n      throw new Error(\"invalid message\");\n    }\n\n    // append data\n    data.set(new Uint8Array(reply.buffer.slice(5)), count);\n\n    // increment\n    count += reply.byteLength - 5;\n\n    // report length\n    if (report) {\n      report(count);\n    }\n  }\n\n  // send \"close\" command\n  cmd = pack(\"o\", 5);\n  await send(session, cmd, true);\n\n  return data;\n}\n\nexport async function writeFile(\n  session: Session,\n  file: string,\n  data: Uint8Array,\n  report: (count: number) => void = null\n) {\n  // send \"create\" command (create & truncate)\n  let cmd = pack(\"oos\", 2, (1 << 0) | (1 << 2), file);\n  await send(session, cmd, true);\n\n  // get MTU\n  let mtu = await session.getMTU();\n\n  // subtract overhead\n  mtu -= 6;\n\n  // write data in chunks\n  let num = 0;\n  let offset = 0;\n  while (offset < data.byteLength) {\n    // determine chunk size and chunk data\n    let chunkSize = Math.min(mtu, data.byteLength - offset);\n    let chunkData = data.slice(offset, offset + chunkSize);\n\n    // determine mode\n    let acked = num % 10 === 0;\n\n    // prepare \"write\" command (acked or silent & sequential)\n    cmd = pack(\"ooib\", 4, acked ? 0 : (1 << 0) | (1 << 1), offset, chunkData);\n\n    // send \"write\" command\n    await send(session, cmd, false);\n\n    // receive ack or \"error\" replies\n    if (acked) {\n      await receive(session, true);\n    }\n\n    // increment offset\n    offset += chunkSize;\n\n    // report offset\n    if (report) {\n      report(offset);\n    }\n\n    // increment count\n    num += 1;\n  }\n\n  // send \"close\" command\n  cmd = pack(\"o\", 5);\n  await send(session, cmd, true);\n}\n\nexport async function renamePath(session: Session, from: string, to: string) {\n  // send command\n  let cmd = pack(\"osos\", 6, from, 0, to);\n  await send(session, cmd, false);\n\n  // await reply\n  await receive(session, true);\n}\n\nexport async function removePath(session: Session, path: string) {\n  // send command\n  let cmd = pack(\"os\", 7, path);\n  await send(session, cmd, true);\n}\n\nexport async function sha256File(session: Session, file: string) {\n  // send command\n  let cmd = pack(\"os\", 8, file);\n  await send(session, cmd, false);\n\n  // await reply\n  let reply = await receive(session, false);\n\n  // verify \"chunk\" reply\n  if (reply.byteLength !== 33 || reply[0] !== 3) {\n    throw new Error(\"invalid message\");\n  }\n\n  // return hash\n  return new Uint8Array(reply.buffer.slice(1));\n}\n\n/* Helpers */\n\nasync function receive(\n  session: Session,\n  expectAck: boolean,\n  timeout = 5000\n): Promise<Uint8Array> {\n  // receive reply\n  let [data] = await session.receive(fsEndpoint, expectAck, timeout);\n  if (!data) {\n    return null;\n  }\n\n  // handle errors\n  if (data[0] === 0) {\n    throw new Error(\"posix error: \" + data[1]);\n  }\n\n  return data;\n}\n\nasync function send(\n  session: Session,\n  data: Uint8Array,\n  awaitAck: boolean,\n  timeout = 5000\n) {\n  // send command\n  await session.send(fsEndpoint, data, awaitAck ? timeout : 0);\n}\n","import { Channel, Device, Queue, QueueList } from \"./device\";\n\nexport function makeHTTPDevice(addr: string): Device {\n  return new HTTPDevice(addr);\n}\n\nexport class HTTPDevice implements Device {\n  private readonly address: string;\n  private ch: Channel | null = null;\n\n  constructor(address: string) {\n    // store address\n    this.address = address;\n  }\n\n  id() {\n    return \"http/\" + this.address;\n  }\n\n  async open(): Promise<Channel> {\n    // check channel\n    if (this.ch) {\n      throw new Error(\"channel already open\");\n    }\n\n    // create socket\n    const socket = new WebSocket(\"ws://\" + this.address);\n\n    // await connections\n    await new Promise((resolve, reject) => {\n      socket.onopen = resolve;\n      socket.onerror = reject;\n    });\n\n    // create list\n    const subscribers = new QueueList();\n\n    // handle messages\n    socket.onmessage = async (msg) => {\n      const data = new Uint8Array(await msg.data.arrayBuffer());\n      subscribers.dispatch(data);\n    };\n\n    // create channel\n    this.ch = {\n      name: () => \"http\",\n      valid() {\n        return true;\n      },\n      subscribe: (q: Queue) => {\n        subscribers.add(q);\n      },\n      unsubscribe(queue: Queue) {\n        subscribers.drop(queue);\n      },\n      write: async (data: Uint8Array) => {\n        socket.send(data);\n      },\n      close: () => {\n        socket.close();\n        this.ch = null;\n      },\n    };\n\n    return this.ch;\n  }\n}\n","import { Queue } from \"async-await-queue\";\n\nimport { Channel, Device } from \"./device\";\nimport { Session, Status } from \"./session\";\n\nexport class ManagedDevice {\n  public device: Device;\n  private pinger: number;\n  private channel: Channel | null;\n  private session: Session | null;\n  private password: string | null = null;\n  private queue = new Queue();\n\n  constructor(device: Device) {\n    // set device\n    this.device = device;\n\n    // start pinger\n    this.pinger = setInterval(async () => {\n      if (this.active()) {\n        await this.useSession(async (session) => {\n          await session.ping(1000);\n        });\n      }\n    }, 5000);\n  }\n\n  async activate() {\n    // check state\n    if (this.active()) {\n      return;\n    }\n\n    // open channel\n    this.channel = await this.device.open();\n  }\n\n  active(): Boolean {\n    return this.channel != null;\n  }\n\n  async locked(): Promise<Boolean> {\n    // check state\n    if (!this.active()) {\n      throw new Error(\"device not active\");\n    }\n\n    // get status\n    let status: Status;\n    await this.useSession(async (session) => {\n      status = await session.status(1000);\n    });\n\n    return (status & Status.locked) != 0;\n  }\n\n  async unlock(password: string): Promise<boolean> {\n    // check state\n    if (!this.active()) {\n      throw new Error(\"device not active\");\n    }\n\n    // unlock\n    let unlocked: boolean;\n    await this.useSession(async (session) => {\n      unlocked = await session.unlock(password, 1000);\n    });\n\n    // store password if unlocked\n    if (unlocked) {\n      this.password = password;\n    }\n\n    return unlocked;\n  }\n\n  async newSession(): Promise<Session> {\n    // check state\n    if (!this.active()) {\n      throw new Error(\"device not active\");\n    }\n\n    // open new session\n    const session = await Session.open(this.channel);\n\n    // get session status\n    let status = await session.status(1000);\n\n    // try to unlock if password is available and locked\n    if (this.password && status & Status.locked) {\n      await session.unlock(this.password, 1000);\n    }\n\n    return session;\n  }\n\n  async useSession(fn: (session: Session) => Promise<void>) {\n    await this.queue.run(async () => {\n      // check state\n      if (!this.active()) {\n        throw new Error(\"device not active\");\n      }\n\n      // open session if absent\n      if (!this.session) {\n        this.session = await this.newSession();\n      }\n\n      // yield session\n      try {\n        await fn(this.session);\n      } catch (e) {\n        // close session\n        this.session.end(1000).then();\n        this.session = null;\n\n        // rethrow\n        throw e;\n      }\n    });\n  }\n\n  async deactivate() {\n    // check state\n    if (!this.active()) {\n      return;\n    }\n\n    // capture state\n    let channel = this.channel;\n    let session = this.session;\n\n    // clear state\n    this.channel = null;\n    this.session = null;\n\n    // end session\n    try {\n      await session.end(1000);\n    } catch (e) {\n      // ignore\n    }\n\n    // close channel\n    channel.close();\n  }\n\n  async stop() {\n    // deactivate\n    await this.deactivate();\n\n    // stop pinger\n    clearInterval(this.pinger);\n\n    // clear device\n    this.device = null;\n  }\n}\n","import { Channel, Message, Queue, read, write } from \"./device\";\nimport { pack, random, toBuffer, toString, unpack } from \"./utils\";\n\nexport enum Status {\n  locked = 1 << 0,\n}\n\nexport class Session {\n  private readonly id: number;\n  private readonly ch: Channel;\n  private readonly qu: Queue;\n  private mtu: number = 0;\n\n  static async open(ch: Channel): Promise<Session> {\n    // prepare queue\n    const queue = new Queue();\n\n    // subscribe to channel\n    ch.subscribe(queue);\n\n    // prepare handle\n    let handle = random(16);\n\n    // begin session\n    await write(ch, new Message(0, 0, toBuffer(handle)));\n\n    // await reply\n    let sid;\n    for (;;) {\n      const reply = await read(queue, 10 * 1000);\n      if (reply.endpoint === 0 && toString(reply.data) === handle) {\n        sid = reply.session;\n        break;\n      }\n    }\n\n    return new Session(sid, ch, queue);\n  }\n\n  constructor(id: number, ch: Channel, qu: Queue) {\n    this.id = id;\n    this.ch = ch;\n    this.qu = qu;\n  }\n\n  async ping(timeout: number = 5000) {\n    // write command\n    await write(this.ch, new Message(this.id, 0xfe, null));\n\n    // read reply\n    const msg = await this.read(timeout);\n\n    // verify reply\n    if (msg.endpoint !== 0xfe || msg.size() !== 1) {\n      throw new Error(\"invalid message\");\n    } else if (msg.data[0] !== 1) {\n      throw new Error(\"session error: \" + msg.data[0]);\n    }\n  }\n\n  async query(endpoint: number, timeout: number = 5000) {\n    // write command\n    await write(this.ch, new Message(this.id, endpoint, null));\n\n    // read reply\n    const msg = await this.read(timeout);\n\n    // verify message\n    if (msg.endpoint !== 0xfe || msg.data.byteLength !== 1) {\n      throw new Error(\"invalid message\");\n    }\n\n    return msg.data[0] === 1;\n  }\n\n  async receive(\n    endpoint: number,\n    expectAck: boolean,\n    timeout: number = 5000\n  ): Promise<[Uint8Array | null, boolean]> {\n    // await message\n    const msg = await this.read(timeout);\n\n    // handle ack\n    if (msg.endpoint === 0xfe) {\n      // check size\n      if (msg.size() !== 1) {\n        throw new Error(\"invalid ack size: \" + msg.size());\n      }\n\n      // check if OK\n      if (msg.data[0] === 1) {\n        if (expectAck) {\n          return [null, true];\n        } else {\n          throw new Error(\"unexpected ack\");\n        }\n      }\n\n      throw parseError(msg.data[0]);\n    }\n\n    // check endpoint\n    if (msg.endpoint !== endpoint) {\n      throw new Error(\"unexpected endpoint: \" + msg.endpoint);\n    }\n\n    return [msg.data, false];\n  }\n\n  async send(endpoint: number, data: Uint8Array, ackTimeout: number) {\n    // write message\n    await write(this.ch, new Message(this.id, endpoint, data));\n\n    // return if timeout is zero\n    if (ackTimeout === 0) {\n      return;\n    }\n\n    // await reply\n    const msg = await this.read(ackTimeout);\n\n    // check reply\n    if (msg.data.byteLength !== 1 || msg.endpoint !== 0xfe) {\n      throw new Error(\"invalid message\");\n    } else if (msg.data[0] !== 1) {\n      throw parseError(msg.data[0]);\n    }\n  }\n\n  async status(timeout: number = 5000): Promise<Status> {\n    // write command\n    let cmd = pack(\"o\", 0);\n    await this.send(0xfd, cmd, 0);\n\n    // wait reply\n    const [reply] = await this.receive(0xfd, false, timeout);\n\n    // verify reply\n    if (reply.length !== 1) {\n      throw new Error(\"invalid message\");\n    }\n\n    // unpack status\n    let status = unpack(\"o\", reply)[0];\n\n    return status as Status;\n  }\n\n  async unlock(password: string, timeout: number = 5000): Promise<boolean> {\n    // prepare command\n    let cmd = pack(\"os\", 1, password);\n    await this.send(0xfd, cmd, 0);\n\n    // wait reply\n    const [reply] = await this.receive(0xfd, false, timeout);\n\n    // verify reply\n    if (reply.length !== 1) {\n      throw new Error(\"invalid message\");\n    }\n\n    return reply[0] === 1;\n  }\n\n  async getMTU(timeout: number = 5000): Promise<number> {\n    // return cached value\n    if (this.mtu > 0) {\n      return this.mtu;\n    }\n\n    // write command\n    let cmd = pack(\"o\", 2);\n    await this.send(0xfd, cmd, 0);\n\n    // wait reply\n    const [reply] = await this.receive(0xfd, false, timeout);\n\n    // verify reply\n    if (reply.length !== 2) {\n      throw new Error(\"invalid message\");\n    }\n\n    // cache value\n    this.mtu = unpack(\"h\", reply)[0];\n\n    return this.mtu;\n  }\n\n  async end(timeout: number = 5000) {\n    // write command\n    await write(this.ch, new Message(this.id, 0xff, null));\n\n    // read reply\n    const msg = await this.read(timeout);\n\n    // verify reply if available\n    if (msg && (msg.endpoint !== 0xff || msg.size() > 0)) {\n      throw new Error(\"invalid message\");\n    }\n\n    // unsubscribe from channel\n    this.ch.unsubscribe(this.qu);\n  }\n\n  async read(timeout: number): Promise<Message> {\n    for (;;) {\n      const msg = await read(this.qu, timeout);\n      if (msg.session === this.id) {\n        return msg;\n      }\n    }\n  }\n}\n\nfunction parseError(num: number): Error {\n  switch (num) {\n    case 1:\n      return new Error(\"invalid session\");\n    case 2:\n      return new Error(\"invalid endpoint\");\n    case 3:\n      return new Error(\"invalid data\");\n    default:\n      return new Error(\"expected ack, got: \" + num);\n  }\n}\n","import { Session } from \"./session\";\nimport { pack, toString } from \"./utils\";\n\nconst metricsEndpoint = 0x05;\n\nexport enum MetricKind {\n  counter,\n  gauge,\n}\n\nexport enum MetricType {\n  long,\n  float,\n  double,\n}\n\nexport interface MetricInfo {\n  ref: number;\n  kind: MetricKind;\n  type: MetricType;\n  name: string;\n  size: number;\n}\n\nexport interface MetricLayout {\n  keys: string[];\n  values: string[][];\n}\n\nexport async function listMetrics(\n  s: Session,\n  timeout: number = 5000\n): Promise<MetricInfo[]> {\n  // send command\n  const cmd = pack(\"o\", 0);\n  await s.send(metricsEndpoint, cmd, 0);\n\n  // prepare list\n  const list: MetricInfo[] = [];\n\n  for (;;) {\n    // receive reply or return list on ack\n    const [reply, ack] = await s.receive(metricsEndpoint, true, timeout);\n    if (ack) {\n      break;\n    }\n\n    // verify reply\n    if (reply.length < 4) {\n      throw new Error(\"Invalid reply\");\n    }\n\n    // parse reply\n    const ref = reply[0];\n    const kind = reply[1];\n    const type = reply[2];\n    const size = reply[3];\n    const name = toString(reply.slice(4));\n\n    // append info\n    list.push({ ref, kind, type, name, size });\n  }\n\n  return list;\n}\n\nexport async function describeMetric(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<MetricLayout> {\n  // send command\n  const cmd = pack(\"oo\", 1, ref);\n  await s.send(metricsEndpoint, cmd, 0);\n\n  // prepare lists\n  let keys: string[] = [];\n  let values: string[][] = [];\n\n  for (;;) {\n    // receive reply\n    const [reply, ack] = await s.receive(metricsEndpoint, true, timeout);\n    if (ack) {\n      break;\n    }\n\n    // verify reply\n    if (reply.length < 1) {\n      throw new Error(\"Invalid reply\");\n    }\n\n    // handle key\n    if (reply[0] === 0) {\n      // verify reply\n      if (reply.length < 3) {\n        throw new Error(\"Invalid reply\");\n      }\n\n      // parse reply\n      const num = reply[1];\n      const key = toString(reply.slice(2));\n\n      // add key\n      keys[num] = key;\n      values[num] = [];\n\n      continue;\n    }\n\n    // handle value\n    if (reply[0] === 1) {\n      // verify reply\n      if (reply.length < 4) {\n        throw new Error(\"Invalid reply\");\n      }\n\n      // parse reply\n      const numKey = reply[1];\n      const numValue = reply[2];\n      const value = toString(reply.slice(3));\n\n      // add value\n      values[numKey][numValue] = value;\n\n      continue;\n    }\n\n    throw new Error(\"Invalid reply\");\n  }\n\n  return {\n    keys: keys,\n    values: values,\n  };\n}\n\nexport async function readMetrics(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<Uint8Array> {\n  // send command\n  const cmd = pack(\"oo\", 2, ref);\n  await s.send(metricsEndpoint, cmd, 0);\n\n  // receive reply\n  const [reply] = await s.receive(metricsEndpoint, false, timeout);\n\n  return reply;\n}\n\nexport async function readLongMetrics(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<number[]> {\n  // receive value\n  const reply = await readMetrics(s, ref, timeout);\n\n  // convert reply\n  let list: number[] = [];\n  for (let i = 0; i < reply.length; i += 4) {\n    list.push(new DataView(reply.buffer).getInt32(i, true));\n  }\n\n  return list;\n}\n\nexport async function readFloatMetrics(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<number[]> {\n  // receive value\n  const reply = await readMetrics(s, ref, timeout);\n\n  // convert reply\n  let list: number[] = [];\n  for (let i = 0; i < reply.length; i += 4) {\n    list.push(new DataView(reply.buffer).getFloat32(i, true));\n  }\n\n  return list;\n}\n\nexport async function readDoubleMetrics(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<number[]> {\n  // receive value\n  const reply = await readMetrics(s, ref, timeout);\n\n  // convert reply\n  let list: number[] = [];\n  for (let i = 0; i < reply.length; i += 8) {\n    list.push(new DataView(reply.buffer).getFloat64(i, true));\n  }\n\n  return list;\n}\n","import { Session } from \"./session\";\nimport { pack, toString } from \"./utils\";\n\nconst paramsEndpoint = 0x01;\n\nexport enum ParamType {\n  raw = 0,\n  string,\n  bool,\n  long,\n  double,\n  action,\n}\n\nexport enum ParamMode {\n  volatile = 1 << 0,\n  system = 1 << 1,\n  application = 1 << 2,\n  locked = 1 << 4,\n}\n\nexport interface ParamInfo {\n  ref: number;\n  type: ParamType;\n  mode: ParamMode;\n  name: string;\n}\n\nexport interface ParamUpdate {\n  ref: number;\n  age: bigint;\n  value: Uint8Array;\n}\n\nexport async function getParam(\n  s: Session,\n  name: string,\n  timeout: number = 5000\n): Promise<Uint8Array> {\n  // prepare command\n  const cmd = pack(\"os\", 0, name);\n\n  // send command\n  await s.send(paramsEndpoint, cmd, 0);\n\n  // receive value\n  const [data] = await s.receive(paramsEndpoint, false, timeout);\n\n  return data;\n}\n\nexport async function setParam(\n  s: Session,\n  name: string,\n  value: Uint8Array,\n  timeout: number = 5000\n): Promise<void> {\n  // prepare command\n  const cmd = pack(\"osob\", 1, name, 0, value);\n\n  // send command\n  await s.send(paramsEndpoint, cmd, timeout);\n}\n\nexport async function listParams(\n  s: Session,\n  timeout: number = 5000\n): Promise<ParamInfo[]> {\n  // send command\n  await s.send(paramsEndpoint, pack(\"o\", 2), 0);\n\n  // prepare list\n  const list: ParamInfo[] = [];\n\n  for (;;) {\n    // receive reply or return list on ack\n    const [reply, ack] = await s.receive(paramsEndpoint, true, timeout);\n    if (ack) {\n      break;\n    }\n\n    // verify reply\n    if (reply.length < 4) {\n      throw new Error(\"Invalid reply\");\n    }\n\n    // parse reply\n    const ref = reply[0];\n    const type = reply[1];\n    const mode = reply[2];\n    const name = toString(reply.slice(3));\n\n    // TODO: Check type and mode.\n\n    // append info\n    list.push({ ref, type, mode, name });\n  }\n\n  return list;\n}\n\nexport async function readParam(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<Uint8Array> {\n  // send command\n  await s.send(paramsEndpoint, pack(\"oo\", 3, ref), 0);\n\n  // receive value\n  const [data] = await s.receive(paramsEndpoint, false, timeout);\n\n  return data;\n}\n\nexport async function writeParam(\n  s: Session,\n  ref: number,\n  value: Uint8Array,\n  timeout: number = 5000\n): Promise<void> {\n  // prepare command\n  const cmd = pack(\"oob\", 4, ref, value);\n\n  // send command\n  await s.send(paramsEndpoint, cmd, timeout);\n}\n\nexport async function collectParams(\n  s: Session,\n  refs: number[],\n  since: bigint,\n  timeout: number = 5000\n): Promise<ParamUpdate[]> {\n  // prepare map\n  let map: bigint = (BigInt(1) << BigInt(64)) - BigInt(1);\n  if (refs.length > 0) {\n    map = BigInt(0);\n    for (const ref of refs) {\n      map |= BigInt(1) << BigInt(ref);\n    }\n  }\n\n  // prepare command\n  const cmd = pack(\"oqq\", 5, map, since);\n\n  // send command\n  await s.send(paramsEndpoint, cmd, 0);\n\n  // prepare list\n  const list: ParamUpdate[] = [];\n\n  for (;;) {\n    // receive reply or return list on ack\n    const [reply, ack] = await s.receive(paramsEndpoint, true, timeout);\n    if (ack) {\n      break;\n    }\n\n    // verify reply\n    if (reply.length < 9) {\n      throw new Error(\"Invalid reply\");\n    }\n\n    // parse reply\n    const view = new DataView(reply.buffer);\n    const ref = reply[0];\n    const age = view.getBigUint64(1, true);\n    const value = reply.slice(9);\n\n    // append info\n    list.push({ ref, age, value });\n  }\n\n  return list;\n}\n\nexport async function clearParam(\n  s: Session,\n  ref: number,\n  timeout: number = 5000\n): Promise<void> {\n  // send command\n  await s.send(paramsEndpoint, pack(\"oo\", 6, ref), timeout);\n}\n","import { Session } from \"./session\";\nimport { pack, unpack } from \"./utils\";\nimport { Channel, Device, Queue, QueueList } from \"./device\";\nimport { ManagedDevice } from \"./managed\";\n\nconst relayEndpoint = 0x04;\n\nexport async function scanRelay(\n  s: Session,\n  timeout: number = 5000\n): Promise<number[]> {\n  // send command\n  const cmd = pack(\"o\", 0);\n  await s.send(relayEndpoint, cmd, 0);\n\n  // receive reply or return list on ack\n  const [reply] = await s.receive(relayEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length != 8) {\n    throw new Error(\"Invalid reply\");\n  }\n\n  // unpack reply\n  let raw = unpack(\"q\", reply)[0] as BigInt;\n\n  // prepare map\n  let list: number[] = [];\n  for (let i = 0; i < 64; i++) {\n    if ((raw & (BigInt(1) << BigInt(i))) != BigInt(0)) {\n      list.push(i);\n    }\n  }\n\n  return list;\n}\n\nexport async function linkRelay(\n  s: Session,\n  device: number,\n  timeout: number = 5000\n): Promise<void> {\n  // send command\n  const cmd = pack(\"oo\", 1, device);\n  await s.send(relayEndpoint, cmd, timeout);\n}\n\nexport async function sendRelay(\n  s: Session,\n  device: number,\n  data: Uint8Array\n): Promise<void> {\n  // send command\n  const cmd = pack(\"oob\", 2, device, data);\n  await s.send(relayEndpoint, cmd, 0);\n}\n\nexport async function receiveRelay(\n  s: Session,\n  timeout: number = 5000\n): Promise<Uint8Array> {\n  // receive reply\n  const [reply] = await s.receive(relayEndpoint, false, timeout);\n\n  return reply;\n}\n\nexport class RelayDevice implements Device {\n  private host: ManagedDevice;\n  private device: number;\n  private ch: Channel | null = null;\n\n  constructor(host: ManagedDevice, device: number) {\n    // store host and device\n    this.host = host;\n    this.device = device;\n  }\n\n  id() {\n    return `${this.host.device.id()}/${this.device}`;\n  }\n\n  async open(): Promise<Channel> {\n    // check channel\n    if (this.ch) {\n      throw new Error(\"channel already open\");\n    }\n\n    // open session\n    const session = await this.host.newSession();\n\n    // link device\n    await linkRelay(session, this.device);\n\n    // create list\n    const subscribers = new QueueList();\n\n    // run receiver\n    (async () => {\n      while (true) {\n        try {\n          // TODO: Use same trick as in swift to directly read from the session.\n          const data = await receiveRelay(session);\n          subscribers.dispatch(data);\n        } catch (e) {\n          console.error(e);\n          break;\n        }\n      }\n    })().then();\n\n    // create channel\n    this.ch = {\n      name: () => \"relay\",\n      valid() {\n        return true;\n      },\n      subscribe: (q: Queue) => {\n        subscribers.add(q);\n      },\n      unsubscribe(queue: Queue) {\n        subscribers.drop(queue);\n      },\n      write: async (data: Uint8Array) => {\n        await sendRelay(session, this.device, data);\n      },\n      close: () => {\n        session.end(0);\n        this.ch = null;\n      },\n    };\n\n    return this.ch;\n  }\n}\n","import { Channel, Device, Queue, QueueList } from \"./device\";\nimport { toBase64, toBuffer, toString } from \"./utils\";\n\nexport async function serialRequest(baudRate = 115200): Promise<Device | null> {\n  // request port\n  let port: SerialPort | null;\n  try {\n    port = await navigator.serial.requestPort();\n  } catch (err) {\n    // ignore\n  }\n  if (!port) {\n    return null;\n  }\n\n  return new SerialDevice(port, baudRate);\n}\n\nexport class SerialDevice implements Device {\n  private readonly port: SerialPort;\n  private readonly baudRate: number;\n  private ch: Channel | null = null;\n\n  constructor(port: SerialPort, baudRate: number) {\n    // store port and baud rate\n    this.port = port;\n    this.baudRate = baudRate;\n\n    // close open chanel if disconnected\n    this.port.addEventListener(\"disconnect\", () => {\n      if (this.ch) {\n        this.ch.close();\n        this.ch = null;\n      }\n    });\n  }\n\n  id() {\n    return \"serial/\" + this.port.getInfo().usbProductId;\n  }\n\n  async open(): Promise<Channel> {\n    // check channel\n    if (this.ch) {\n      throw new Error(\"channel already open\");\n    }\n\n    // connect, if not connected already\n    if (!this.port.readable) {\n      await this.port.open({\n        baudRate: this.baudRate,\n      });\n    }\n\n    // create list\n    const subscribers = new QueueList();\n\n    // create reader\n    const reader = this.port.readable.getReader();\n\n    // read data\n    const read = async () => {\n      try {\n        let buffer = \"\";\n\n        while (true) {\n          // read data\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n\n          // Decode the chunk and add it to the buffer\n          buffer += toString(value);\n\n          // Split the buffer into lines\n          let lines = buffer.split(\"\\n\");\n\n          // Process all complete lines\n          for (let i = 0; i < lines.length - 1; i++) {\n            if (lines[i].startsWith(\"NAOS!\")) {\n              const data = lines[i].slice(5);\n              subscribers.dispatch(\n                Uint8Array.from(atob(data), (c) => c.charCodeAt(0))\n              );\n            }\n          }\n\n          // Save the last incomplete line back to the buffer\n          buffer = lines[lines.length - 1];\n        }\n      } catch (err) {\n        console.error(\"Error reading stream:\", err);\n      } finally {\n        reader.releaseLock();\n      }\n    };\n\n    // start reading\n    read().then();\n\n    // create writer\n    const writer = this.port.writable.getWriter();\n\n    // create channel\n    this.ch = {\n      name: () => \"serial\",\n      valid() {\n        return true;\n      },\n      subscribe: (q: Queue) => {\n        subscribers.add(q);\n      },\n      unsubscribe(queue: Queue) {\n        subscribers.drop(queue);\n      },\n      write: async (data: Uint8Array) => {\n        await writer.write(toBuffer(\"NAOS!\"));\n        await writer.write(toBase64(data));\n        await writer.write(toBuffer(\"\\n\"));\n      },\n      close: () => {\n        writer.close();\n        writer.releaseLock();\n        reader.cancel();\n        reader.releaseLock();\n        this.ch = null;\n      },\n    };\n\n    return this.ch;\n  }\n}\n","import { Session } from \"./session\";\nimport { pack } from \"./utils\";\n\nconst updateEndpoint = 0x2;\n\nexport async function update(\n  session: Session,\n  data: Uint8Array,\n  report: (count: number) => void = null,\n  timeout: number = 30000\n) {\n  // send \"begin\" command\n  let cmd = pack(\"oi\", 0, data.length);\n  await session.send(updateEndpoint, cmd, 0);\n\n  // receive reply\n  let [reply] = await session.receive(updateEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length !== 1 && reply[0] !== 0) {\n    throw new Error(\"invalid message\");\n  }\n\n  // get MTU\n  let mtu = await session.getMTU();\n\n  // subtract overhead\n  mtu -= 6;\n\n  // write data in chunks\n  let num = 0;\n  let offset = 0;\n  while (offset < data.length) {\n    // determine chunks size\n    let chunkSize = Math.min(mtu, data.length - offset);\n    let chunkData = data.slice(offset, offset + chunkSize);\n\n    // determine acked\n    let acked = num % 10 == 0;\n\n    // send \"write\" command\n    cmd = pack(\"oob\", 1, acked ? 1 : 0, chunkData);\n    await session.send(updateEndpoint, cmd, acked ? timeout : 0);\n\n    // increment offset\n    offset += chunkSize;\n\n    // report offset\n    if (report) {\n      report(offset);\n    }\n\n    // increment counter\n    num++;\n  }\n\n  // send \"finish\" command\n  cmd = pack(\"o\", 3);\n  await session.send(updateEndpoint, cmd, 0);\n\n  // receive reply\n  [reply] = await session.receive(updateEndpoint, false, timeout);\n\n  // verify reply\n  if (reply.length !== 1 && reply[0] !== 1) {\n    throw new Error(\"invalid message\");\n  }\n}\n"],"names":[],"version":3,"file":"main.js.map"}